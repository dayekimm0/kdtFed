/*

1.자료구조 & 알고리즘 무엇인가?
- 자료구조 : 어떤 데이터(*자료)가 어떤 형태(*구조)로 저장이되고, 어떻게 사용되는지를 나타내는 것 => 아마추어 // 프로
- 알고리즘 : 어떤 문제를 해결하기 위한 확실한 해결방법

2. 왜 갈수록 중요해지고 있을까?
- 전공과목 > 지금당장 코드를 작성하는데 큰 영향을 주지 못함
- 비전공자 > 3년차
- 기본코드 > AI가 더 잘 만들어준다

3. 어떤 자료구조와 알고리즘을 사용하는 것이 효과적인가?를 어떻게 구분.판단?
- 시간복잡도(*알고리즘 효율성 측정 척도) 개념 적용
- 시간복잡도 => 해당 문제를 해결하기 위해서 얼만큼 시간이 걸렸는가
- 코드를 실행하고 결과값을 도출하는데 걸리는 시간
- 만약 코드 스타트 => 코드 종료 (*단순 처리시간만 체크) => 이 방식으로는 문제가 있다!!!
- 순수하게 코드 자체만으로 해당 코드의 효율성을 측정해야할 필요 존재
- 코드를 보고, 코드 안에 어떤 문제를 해결하는데 있어서 가장 많은 시간을 소비할 것으로
판단되는 요소의 실행 횟수 및 개수
- 반복문을 활용해서 반복을 많이 하면 할 수록 문제를 처리하는데 소요되는 시간은
많아질것이고, 그만큼 코드의 효율성은 떨어질 수 밖에 없다!!!

*/

// ex.1
const a = 87;
const b = 70;
const c = 100;

const average = (a + b + c) / 3;
console.log(average);

// ex.2
const arr = [87, 70, 100];

let average01 = 0;

for (let i = 0; i < arr.length; i++) {
  average01 += arr[i];
}

average01 /= arr.length;

console.log(average01);

// ex.3
// 아래 주어진 배열에서 5를 찾아보세요!!!

const arr01 = [1, 3, 5, 7];

// 5라는 숫자를 상기 배열에서 찾을 수 있는 경우의 수
// 1.반복문이 실행된 이후에 바로 찾는 경우 -> 빅오메가
// 2.반복문이 실행된 이후에 모든 배열 요소를 순회하고 가장 마지막 번째에 찾는 경우 -> 빅오
// 3.반복문이 실행된 이후 배열 요소의 절반 정도만 순회하고 찾는 경우 -> 빅세타

// 시간복잡도 예시 1
// (총 연산 횟수)덧셈 연산 1회 - 곱셈 연산 1회 - 나눗셈 연산 1회 => 시간복잡도 = 빅오(3)
const addUpTo1 = (n) => {
  return (n * (n + 1)) / 2;
};

// 시간복잡도 예시 2
// total 변수 선언 및 값 할당 1회
// i 변수 선언 및 값 할당 1회
// i 와 n의 비교 n회
// i 덧셈 n회
// i 증가 n회
// 5n + 2회
// 10을 대입 => 50 + 2 = 52 빅오(5n)
const addUpTo2 = (n) => {
  let total = n;
  for (let i = 0; i < n; i++) {
    total += i;
  }
  return total;
};
// 빅오를 활용한 시간복잡도 종류
// 1. 상수시간 복잡도 : 빅오 인자값으로 들어가는 값이 상수 빅오(8)
// 2. 로그시간 복잡도
// 3. 선형시간 복잡도
// 4. 다항시간 복잡도

// 배열 vs 연결리스트
// 자바스크립트 배열 -> 특수함
// 컴퓨터 내 메모리 공간 자유롭게 사용할 수 있도록 설계

/* 스택(stack) -> LIFO
- 데이터를 쌓아올리는 형태의 자료구조
Last In First Out
- 생활애서 만날 수 있는 스택 형식의 상황 : 설거지 // 엘리베이터
- 배열 혹은 연결리스트를 활용해서 스택 자료구조 생성 가능

만약, 연결리스트를 활용해서 스택의 자료구조를 생성한다면?
- 데이터 삽입을 무조건 첫 번째 인덱스로만 실행을 해주면 가능 !
- 데이터 제거를 무조건 첫 번째 인덱스에서만 실행을 할 수 있게 해주면 가능 !

스택 형식의 자료구조를 띄고 있는 연결리스트의 추상 자료형 데이터 타입기능 생성
1) push() : 데이터 삽입
2) pop() : 데이터 제거
3) peek() : 데이터 참조
4) isEmpty() : 데이터 존재 여부 확인
*/
